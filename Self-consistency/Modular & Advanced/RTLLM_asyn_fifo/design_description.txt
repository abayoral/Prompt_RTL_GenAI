As a professional Verilog designer, your task is to implement an asynchronous FIFO (First-In, First-Out) buffer with configurable bit width and depth. The FIFO should be structured into distinct components, including a dual-port RAM module used for data storage, which must be instantiated as a submodule. The dual-port RAM should accept the following inputs: write clock (`wclk`), write enable (`wenc`), write address (`waddr`), write data (`wdata`), read clock (`rclk`), read enable (`renc`), and read address (`raddr`). It should also provide the read data (`rdata`) as output, which should be a registered output.

The FIFO is divided into several functional parts. Firstly, the dual-port RAM handles data storage, with separate ports for read and write operations. Then, you will need to design a data write controller to manage writing data, and a data read controller to handle reading data. Additionally, two pointer synchronizers need to be implemented: one for synchronizing the read pointer using the write clock, and another for synchronizing the write pointer with the read clock. The synchronization ensures stability when interfacing between different clock domains in an asynchronous FIFO environment.

In terms of logic for detecting when the FIFO is 'empty' or 'full', use Gray code to minimize race conditions. For a FIFO depth of 8, use 4-bit Gray codes for the read and write pointers. Convert the Gray-coded pointers back to binary to generate addresses for accessing the RAM. A FIFO is considered empty when the read and write pointers match. Conversely, it is deemed full when the read and write pointers differ only in the most significant bit and have all other bits identical.

For the module `asyn_fifo`, specify the inputs for the write clock signal (`wclk`), read clock signal (`rclk`), write reset signal (`wrstn`), read reset signal (`rrstn`), write increment signal (`winc`), read increment signal (`rinc`), and the input data (`wdata`). The outputs should include the `wfull` and `rempty` flags indicating the status of the FIFO, and the read data (`rdata`).

Ensure that parameters such as `WIDTH` and `DEPTH` are configurable, defaulting to 8 bits and 16 entries, respectively. This configurability will allow the FIFO's storage capacity and data width to be adjusted as per requirements. Your implementation must cater to both the logic for updating the pointers and converting between Gray code and binary for accurate address mapping, and maintain synchronization between asynchronous read and write operations using suitable clock domain crossing techniques.