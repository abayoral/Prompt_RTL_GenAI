Imagine you are tasked with designing a finite state machine (FSM) that controls an output signal based on two input signals, s and w. The FSM kicks off its operation in a default reset state labeled as A, and it stays in this state as long as the input signal s is equal to 0. However, when s becomes 1, the FSM transitions from state A to a new state B. Once the FSM enters state B, it begins to monitor the input signal w over the course of the next three consecutive clock cycles. The FSM's main job in this phase is to count how many times the input w is set to 1 during these three cycles. If, by the end of these three cycles, the FSM has observed that w was equal to 1 exactly twice, it will react by setting an output signal z to 1 during the very next clock cycle. If this specific condition is not met, meaning w equals 1 either fewer or more than two times, then the output z will be set to 0 instead.

After deciding the value of z based on the above conditions, the FSM does not halt but rather continues to monitor the input w, repeating the same three-clock-cycle evaluation process indefinitely, or until new instructions are provided. Notably, it is important to remember that the input signal s plays a role only when the FSM is in state A, serving as the trigger to move out of this state. Throughout the operation in state B, the only input the FSM is concerned with is w.

The goal of this task is to conceptualize and implement this FSM with an efficient use of resourcesâ€”specifically, to design it using the fewest number of states possible while achieving the described functionality. Following this operational logic is a timing diagram that outlines the expected behavior of the output z based on varying sequences of input w during the FSM's operation, providing a visual aid for understanding the timing requirements of the output state changes.

You are to write a module in Verilog that effectively incorporates these requirements, managing inputs and generating the appropriate output based on the described rules. Your task involves writing the Verilog code within a given framework that defines the inputs and output, as well as a synchronous reset to initialize the FSM. Remember, the challenge is to keep the FSM design as simple and streamlined as possible, minimizing the number of states while fulfilling the task's conditions.