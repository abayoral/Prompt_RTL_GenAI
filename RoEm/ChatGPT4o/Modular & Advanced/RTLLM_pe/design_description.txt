Imagine you are a highly skilled Verilog designer tasked with developing a component known as a Multiplying Accumulator, also referred to as a MAC (Multiply-Accumulate unit), specifically tailored for handling 32-bit integers. The focus here is on the detailed specification and intended operation of this component. Within this system, we refer to the module as "pe" (processing element). The design requires the integration of a mechanism to effectively store intermediate results during the accumulation process, making use of a dedicated register. This register plays a crucial role as it holds onto the partial sum, essentially the intermediate accumulation result from previous cycles. In each operational cycle of the system, the component performs the task of taking two input integers, 'a' and 'b', multiplying them to produce a result. This result is then added to whatever existing value is stored within the register in order to maintain a running total, represented by the output port 'c'.

The module should be defined with specific input and output ports to facilitate its function. As inputs, the module must accept: 
1. `clk` - a clock signal that governs the timing of synchronous operations within the logic.
2. `rst` - a reset signal that is active when set to '1', signaling the module to initiate a reset and inactive when set to '0'.
3. `a` - a 32-bit bus carrying the first operand for multiplication.
4. `b` - a 32-bit bus carrying the second operand for multiplication.

For its output, the module should provide:
- `c` - a 32-bit bus that outputs the current accumulated total or sum.

The implementation of this design involves a parallel multiplication and accumulation process within the Verilog code. This encompasses the use of registers alongside an "always" block to carry out the multiplication and summation tasks. The updating of the accumulator register `c` occurs on either the rising edge of the clock signal (`clk`) or the reset signal (`rst`). Upon detecting an active reset signal, the module should initialize the `c` register to a value of 0, effectively clearing the accumulated result. Conversely, if the reset signal is inactive, the module proceeds to update the `c` register by integrating the product of input operands `a` and `b` with the register's current value, thereby performing the accumulation.

To encapsulate this behavior within Verilog, provide a comprehensive piece of code delineating these processes. The code should accurately model the described multiplication and accumulation operations while ensuring synchronization with both clock and reset signals, highlighting the inherent reset capability and circulation of output through the `c` register.