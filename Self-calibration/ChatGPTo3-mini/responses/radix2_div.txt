Below is one acceptable corrected version. In our “fix” we noticed that although the code correctly takes the absolute value of the dividend and divisor, it never “restores” the sign of the quotient (and remainder) when a signed division is requested. (There was also a few minor clean‐up issues.) One acceptable fix is to compute the final quotient and remainder with sign–correction in the DONE state. One complete corrected version is given below:

------------------------------------------------------------
module radix2_div(
  input         clk,
  input         rst,
  input         sign,        // 1: perform signed division; 0: assume unsigned
  input  [7:0]  dividend,
  input  [7:0]  divisor,
  input         opn_valid,
  output reg    res_valid,
  output reg [15:0] result     // {remainder, quotient}
);

  // state definitions
  localparam IDLE = 2'b00,
             CALC = 2'b01,
             DONE = 2'b10;

  reg [1:0] state;
  reg [3:0] cnt;         // 4-bit counter (counts 0 to 7)

  // Internal shift register holds {Remainder, Quotient}.
  // At any time, SR[15:8] is the current remainder and SR[7:0] is the quotient.
  reg [15:0] SR;

  // To support signed/unsigned division, we take the absolute values.
  reg [7:0] dividend_abs, divisor_abs;
  // Compute two’s complement (negated divisor) for subtraction:
  wire [7:0] neg_divisor;
  assign neg_divisor = ~divisor_abs + 1;

  // Combinational absolute value computation for dividend.
  always @(*) begin
    if (sign && dividend[7])
      dividend_abs = ~dividend + 1;
    else
      dividend_abs = dividend;
  end

  // Combinational absolute value computation for divisor.
  always @(*) begin
    if (sign && divisor[7])
      divisor_abs = ~divisor + 1;
    else
      divisor_abs = divisor;
  end

  // ------------------------------------------------------------------------
  // The division algorithm is based on the restoring (radix‐2) method.
  // Procedure:
  // 1. In IDLE: When opn_valid is high, capture the inputs and initialize SR.
  //    SR <= {8'b0, dividend_abs};
  // 2. In CALC: For 8 iterations:
  //    a) Shift left the {R, Q} pair by 1 bit. (R_shift = {R[6:0], Q[7]})
  //    b) Compute subtraction: sub = R_shift - divisor_abs.
  //       If sub produces a carry-out (i.e. no borrow), then the subtraction is 
  //       successful. In that case, update R to sub[7:0] and set Q's LSB to 1.
  //    Formally:
  //         next_R = (sub[8]==1) ? sub[7:0] : R_shift;
  //         next_Q = { Q[6:0], sub[8] };
  //         SR <= {next_R, next_Q};
  // 3. In DONE: After 8 iterations, SR holds the final result. Then perform sign
  //    correction (if required), and assert res_valid.
  // ------------------------------------------------------------------------

  // Split SR into R and Q.
  wire [7:0] R = SR[15:8];
  wire [7:0] Q = SR[7:0];

  // Compute the shifted remainder.
  wire [7:0] R_shift = { R[6:0], Q[7] };
  // The quotient is shifted left by 1, with a 0 appended.
  // (The new LSB will be replaced according to sub[8])
  // [The intermediate Q_shift signal is not needed since we build next_Q directly.]

  // Do subtraction on R_shift: R_shift - divisor_abs via two’s complement addition.
  // The 9-bit addition produces a carry-out in sub[8] if R_shift >= divisor_abs.
  wire [8:0] sub;
  assign sub = {1'b0, R_shift} + {1'b0, neg_divisor};

  // Determine next remainder and next quotient.
  wire [7:0] next_R = sub[8] ? sub[7:0] : R_shift;
  wire [7:0] next_Q = { Q[6:0], sub[8] };

  //----------------------------------------------
  // Synchronous state machine.
  //----------------------------------------------
  // We add sign-correction in DONE.
  reg [7:0] quotient_corr, remainder_corr;
  always @(posedge clk or posedge rst) begin
    if(rst) begin
      state     <= IDLE;
      SR        <= 16'b0;
      cnt       <= 4'b0;
      res_valid <= 1'b0;
      result    <= 16'b0;
    end else begin
      case(state)
        IDLE: begin
          res_valid <= 1'b0;
          if(opn_valid) begin
            // Capture inputs and initialize the shift register.
            // The remainder is set to 0 and the quotient to the absolute dividend.
            SR  <= {8'b0, dividend_abs};
            cnt <= 4'b0;
            state <= CALC;
          end
        end

        CALC: begin
          // One iteration of the shift-subtract algorithm.
          SR  <= { next_R, next_Q };
          cnt <= cnt + 1;
          if(cnt == 4'd7)
            state <= DONE;
        end

        DONE: begin
          // Perform sign-correction if needed.
          if(sign) begin
            // For the quotient, if dividend and divisor have opposite signs, negate.
            if(dividend[7] ^ divisor[7])
              quotient_corr <= ~SR[7:0] + 1;
            else
              quotient_corr <= SR[7:0];

            // Remainder takes the sign of the dividend.
            if(dividend[7])
              remainder_corr <= ~SR[15:8] + 1;
            else
              remainder_corr <= SR[15:8];

            result <= {remainder_corr, quotient_corr};
          end
          else begin
            result <= SR;
          end
          res_valid <= 1'b1;
          // Wait here until opn_valid goes low before returning to IDLE.
          if(!opn_valid)
            state <= IDLE;
        end

        default: state <= IDLE;
      endcase
    end
  end

endmodule
------------------------------------------------------------

Explanation of the changes:
1. Added a sign‐correction block in the DONE state. Now, if “sign” is asserted, the module checks whether the dividend and divisor have opposite signs (using XOR) and negates the quotient if so. The remainder is adjusted to have the same sign as the dividend.
2. Minor clean–up comments and formatting (for example, replacing “4‐bit” with “4‐bit” and clarifying comments) have been applied.

This module now correctly implements the radix–2 division algorithm with signed/unsigned support according to best practices.